{
  "version": 3,
  "sources": [
    "unknown"
  ],
  "names": [
    "cc",
    "Class",
    "extends",
    "Component",
    "properties",
    "cell_bg",
    "type",
    "Prefab",
    "default",
    "puzzleCell",
    "touchCellList",
    "Node",
    "onLoad",
    "purCellList",
    "i",
    "j",
    "node",
    "instantiate",
    "parent",
    "active",
    "position",
    "x",
    "y",
    "push",
    "puzzleController",
    "mapData",
    "getPuzzleMap",
    "console",
    "log",
    "JSON",
    "stringify",
    "cellList",
    "index",
    "getComponent",
    "init",
    "referCellUI",
    "length",
    "cell",
    "getIsOnTouchMap",
    "puzzleCellTouchEnd",
    "target",
    "minDis",
    "purPos",
    "undefined",
    "purCell",
    "pos",
    "touchEndPos",
    "distance",
    "pDistance",
    "nodeMinDis",
    "getIsOnMap",
    "dis",
    "setOnMap",
    "setOnTouchMap",
    "puzzleCellTouchBegan",
    "zIndex"
  ],
  "mappings": "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",
  "file": "unknown",
  "sourcesContent": [
    "import PuzzleController from './puzzle_controller'\nimport defines from './game_defines'\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        cell_bg: {\n            type: cc.Prefab,\n            default: null\n        },\n        puzzleCell: {\n            type: cc.Prefab,\n            default: null\n        },\n        touchCellList: {\n            type: cc.Node,\n            default: []\n        }\n    },\n\n    // use this for initialization\n    onLoad: function () {\n\n        this.purCellList = [];\n        for (let i = 0 ; i < 2 ; i ++){\n            for (let j = 0 ; j < 3 ; j ++){\n                let node = cc.instantiate(this.cell_bg);\n                node.parent = this.node;\n                node.active = false;\n                node.position = {\n                    x: (3 - 1) * - 0.5 * 260 + j * 260,\n                    y: 180 +  260 * i\n                };\n                this.purCellList.push(node);\n            }\n        }\n\n\n        //初始化一个地图\n        this.puzzleController = PuzzleController();\n        let mapData = this.puzzleController.getPuzzleMap();\n        console.log('map data = ' + JSON.stringify(mapData));\n\n        //初始化碎片节点\n        this.cellList = [];\n        let index = 0;\n        for (let i in mapData){\n            let node = cc.instantiate(this.puzzleCell);\n            node.parent = this.node;\n            node.getComponent(\"puzzle_cell\").init(mapData[i],this,index);\n            this.cellList.push(node);\n            index ++;\n        }\n        this.referCellUI();\n    }\n    ,\n    referCellUI : function () {\n        let index = 0;\n       for (let i = 0 ; i < this.cellList.length ; i ++){\n           let cell = this.cellList[i];\n           if (cell.getComponent('puzzle_cell').getIsOnTouchMap()){\n               // console.log('is on map');\n               cell.active = true;\n                if (index < 3){\n                    cell.position = this.touchCellList[index].position;\n                }else {\n                    cell.active = false;\n                }\n               index ++;\n\n           }\n       }\n    },\n    puzzleCellTouchEnd: function (target) {\n      // x\n        //得到最近的点\n        let minDis = 10000;\n        let purPos = undefined;\n        for (let i = 0 ; i < this.purCellList.length ; i ++){\n            let purCell = this.purCellList[i];\n            let pos = purCell.position;\n            let touchEndPos = target.node.position;\n            let distance = cc.pDistance(pos,touchEndPos);\n            if (distance < minDis){\n                minDis = distance;\n                purPos = pos;\n            }\n        }\n        //再次检测碰撞\n        let nodeMinDis = 10000;\n        for  (let i = 0 ; i < this.cellList.length ; i ++){\n            let node = this.cellList[i];\n            if (node.getComponent('puzzle_cell').getIsOnMap()){\n                let dis = cc.pDistance(purPos, node.position);\n                if (dis < nodeMinDis){\n                    nodeMinDis = dis;\n                }\n            }\n        }\n        if (minDis < 140 && nodeMinDis > 140){\n            target.node.position = purPos;\n            target.setOnMap();\n        }else {\n            target.setOnTouchMap();\n\n        }\n        this.referCellUI();\n        // cc.log(\"mndis = \" + minDis);\n\n    },\n    puzzleCellTouchBegan: function (target) {\n\n        for (let i in this.cellList){\n            this.cellList[i].zIndex = 10;\n        }\n        target.node.zIndex = 100;\n        this.referCellUI();\n\n    }\n});\n"
  ]
}